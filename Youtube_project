pip install google-api-python-client
pip install sqlalchemy
pip install mysqlclient

import googleapiclient.discovery
from googleapiclient.discovery import build
import pymongo
import pandas as pd
import sqlalchemy as sa
import streamlit as st

api_service_name = "youtube"
api_version = "v3"
api_key = 'AIzaSyChxcS4G0thj6eLminxF7VKEDYWEeoqfMM'
youtube = build('youtube', 'v3', developerKey=api_key)
def get_channel_details(channel_id):
    request = youtube.channels().list(part = 'snippet,contentDetails,statistics,status',id = channel_id)
    response = request.execute()
    for item in response["items"]:
            data = {
                    'channel_id':str(item["id"]),
                    'channel_name':str(item["snippet"]["title"]),
                    'channel_launch_date':item["snippet"]["publishedAt"],
                    'channel_description':item["snippet"]["description"],
                    'channel_views':int(item["statistics"]["viewCount"]),
                    'channel_subscription':int(item["statistics"]["subscriberCount"]),
                    'channel_video_count':int(item["statistics"]["videoCount"]),
                    'channel_playlist_id':item["contentDetails"]["relatedPlaylists"]["uploads"]
                    }
    return(data)

def get_playlist_details(playlist):
  video_id = []
  next_page_token = None
  while True:
      request = youtube.playlistItems().list(part = 'contentDetails', playlistId = playlist,  maxResults = 50, pageToken = next_page_token)
      response = request.execute()
      for item in response["items"]:
          video_id.append(item["contentDetails"]["videoId"])
      next_page_token = response.get("nextPageToken")
      if not next_page_token:
        break
  return video_id

def get_video_details(video_ids):
  video_details =[]
  for video_id in video_ids:
    request = youtube.videos().list(part = 'snippet,contentDetails,statistics', id = video_id)
    response = request.execute()
    for item in response["items"]:
        data = {
              'video_id' : item["id"],
              'channel_id' : item["snippet"]["channelId"],
              'channel_name' : item["snippet"]["channelTitle"],
              'video_name' : item["snippet"]["title"],
              'video_date' : item["snippet"]["publishedAt"],
              'video_description' : item["snippet"]["description"],
              'video_duration' :duration(item["contentDetails"]["duration"]),
              'video_views' : int(item["statistics"]["viewCount"])if 'viewCount' in response['items'][0]['statistics'] else 0,
              'video_likes' : int(item["statistics"]["likeCount"]) if 'likeCount' in response['items'][0]['statistics'] else 0,
              'video_dislikes' :int( item["statistics"]["dislikeCount"]) if 'dislikeCount' in response['items'][0]['statistics'] else 0,
              'video_favourite' : int(item["statistics"]["favoriteCount"]) if 'favoriteCount' in response['items'][0]['statistics'] else 0,
              'video_comment_count' : int(item["statistics"]["commentCount"]) if 'commentCount' in response['items'][0]['statistics'] else 0,
              }
        video_details.append(data)
  return video_details

def get_comment_details(video_ids):
    comment_list = []
    for video_id in video_ids:
        try:
            request = youtube.commentThreads().list(part='snippet', videoId=video_id, maxResults=50)
            response = request.execute()
            if 'items' not in response:
                continue
            for item in response["items"]:
                 comment_details = {
                        'comment_id': item['snippet']['topLevelComment']['id'],
                        'video_id': video_id,
                        'comment_text': item['snippet']['topLevelComment']['snippet']['textDisplay'],
                        'comment_author': item['snippet']['topLevelComment']['snippet']['authorDisplayName'],
                        'commented_on': item['snippet']['topLevelComment']['snippet']['publishedAt']
                        }
                 comment_list.append(comment_details)
        except :
            continue
    return comment_list

from pymongo import MongoClient
client = pymongo.MongoClient("mongodb+srv://pnhurukadli:O9IWeOJZj89cJxwe@cluster0.tmqwxri.mongodb.net/?retryWrites=true&w=majority")
db = client['test']
db

db = client['youtube']
col_1 = db['channel_details']
def get_channel_details_1(channel_id):
    api_key = "AIzaSyChxcS4G0thj6eLminxF7VKEDYWEeoqfMM"
    api_service_name = "youtube"
    api_version = "v3"

    youtube = build(api_service_name, api_version, developerKey=api_key)
    request = youtube.channels().list(part = 'snippet,contentDetails,statistics,status',id = channel_id)
    response = request.execute()
    for item in response["items"]:
            data = {
                    'channel_id':str(item["id"]),
                    'channel_name':str(item["snippet"]["title"]),
                    'channel_launch_date':item["snippet"]["publishedAt"],
                    'channel_description':item["snippet"]["description"],
                    'channel_views':int(item["statistics"]["viewCount"]),
                    'channel_subscription':int(item["statistics"]["subscriberCount"]),
                    'channel_video_count':int(item["statistics"]["videoCount"]),
                    'channel_playlist_id':item["contentDetails"]["relatedPlaylists"]["uploads"]
                    }
    return(data)


db = client['youtube']
col_2 = db['video_details']
def get_video_details(video_ids):
  video_details =[]
  api_key = "AIzaSyChxcS4G0thj6eLminxF7VKEDYWEeoqfMM"
  api_service_name = "youtube"
  api_version = "v3"
  youtube = build(api_service_name, api_version, developerKey=api_key)
  for video_id in video_ids:
    request = youtube.videos().list(part = 'snippet,contentDetails,statistics', id = video_id)
    response = request.execute()
    for item in response["items"]:
        data = {
              'video_id' : item["id"],
              'channel_id' : item["snippet"]["channelId"],
              'channel_name' : item["snippet"]["channelTitle"],
              'video_name' : item["snippet"]["title"],
              'video_date' : item["snippet"]["publishedAt"],
              'video_description' : item["snippet"]["description"],
              'video_duration' :item["contentDetails"]["duration"],
              'video_views' : int(item["statistics"]["viewCount"])if 'viewCount' in response['items'][0]['statistics'] else 0,
              'video_likes' : int(item["statistics"]["likeCount"]) if 'likeCount' in response['items'][0]['statistics'] else 0,
              'video_dislikes' :int( item["statistics"]["dislikeCount"]) if 'dislikeCount' in response['items'][0]['statistics'] else 0,
              'video_favourite' : int(item["statistics"]["favoriteCount"]) if 'favoriteCount' in response['items'][0]['statistics'] else 0,
              'video_comment_count' : int(item["statistics"]["commentCount"]) if 'commentCount' in response['items'][0]['statistics'] else 0,
              }
        video_details.append(data)
  return(video_details)


db = client['youtube']
col_3 = db['comment_details']
def get_comment_details(video_ids):
    comment_list = []
    api_key = "AIzaSyChxcS4G0thj6eLminxF7VKEDYWEeoqfMM"
    api_service_name = "youtube"
    api_version = "v3"
    youtube = build(api_service_name, api_version, developerKey=api_key)
    for video_id in video_ids:
        try:
            request = youtube.commentThreads().list(part='snippet', videoId=video_id, maxResults=50)
            response = request.execute()
            if 'items' not in response:
                continue
            for item in response["items"]:
                 comment_details = {
                        'comment_id': item['snippet']['topLevelComment']['id'],
                        'video_id': video_id,
                        'comment_text': item['snippet']['topLevelComment']['snippet']['textDisplay'],
                        'comment_author': item['snippet']['topLevelComment']['snippet']['authorDisplayName'],
                        'commented_on': item['snippet']['topLevelComment']['snippet']['publishedAt']
                        }
                 comment_list.append(comment_details)
        except :
            continue
    return comment_list

def get_channel_details_1(channel_id):
    ch_details = get_channel_details(channel_id)
    playlist = ch_details["channel_playlist_id"]
    video_ids = get_playlist_details(playlist)
    vi_ids =  get_video_details(video_ids)
    com_details = get_comment_details(video_ids)
    coll1 = db["channel_details"]
    coll1.insert_one({"channel_information":ch_details,"video_information":vi_ids," comment_information":com_details})
    return "uploaded completed successfully"

ch_list = []
db = client["youtube"]
coll1 = db["channel_details"]
for ch_data in coll1.find({},{"_id":0}):
    ch_list.append(ch_data["channel_information"])
df = pd.DataFrame(ch_list)
df


import mysql.connector
mycon = mysql.connector.connect(
    host = "localhost",
    user = "root",
    password="12345",
    database = "youtube"
)
mycursor = mycon.cursor()

create_query = '''CREATE TABLE IF NOT EXISTS youtube.channel_information (
                   channel_name VARCHAR(255),
                   channel_id VARCHAR(255),
                   channel_subscription INT,
                   channel_views INT,
                   channel_video_count INT,
                   channel_description TEXT,
                   channel_playlist_id VARCHAR(255)
                )'''

try:
    mycursor.execute(create_query)
except Exception as e:
    print(f"Error creating table: {e}")

for index, row in df.iterrows():
    insert_query = '''Insert into channel_information (channel_name,
                                          channel_id,
                                          channel_subscription,
                                          channel_views,
                                          channel_video_count,
                                          channel_description,
                                          channel_playlist_id)
                      values (%s, %s, %s, %s, %s, %s, %s)'''
    values = (row['channel_name'],
              row['channel_id'],
              row['channel_subscription'],
              row['channel_views'],
              row['channel_video_count'],
              row['channel_description'],
              row['channel_playlist_id'])

    try:
        mycursor.execute(insert_query, values)
    except Exception as e:
        print(f"Error inserting data: {e}")

vi_list = []
db = client["youtube"]
coll1 = db["channel_details"]

for vi_data in coll1.find({}, {"_id": 0, "video_information": 1}):
    video_info = vi_data.get("video_information")
    if video_info is not None:
        vi_list.extend(video_info)

df1 = pd.DataFrame(vi_list)
df1

create_query = '''CREATE TABLE IF NOT EXISTS youtube.video_information (
                   video_id VARCHAR(255),
                   channel_id VARCHAR(255),
                   channel_name VARCHAR(255),
                   video_name VARCHAR(255),
                   video_date VARCHAR(255),
                   video_description TEXT,
                   video_duration TEXT,
                   video_views BIGINT,
                   video_likes BIGINT,
                   video_favourite INT,
                   video_comment_count INT
                )'''

try:
    mycursor.execute(create_query)
except Exception as e:
    print(f"Error creating table: {e}")

for index, row in df1.iterrows():
    insert_query = '''Insert into video_information (video_id,
                                          channel_id,
                                          channel_name,
                                          video_name,
                                          video_date,
                                          video_description,
                                          video_duration,
                                          video_views,
                                          video_likes,
                                          video_favourite,
                                          video_comment_count)
                      values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'''
    values = (row['video_id'],
              row['channel_id'],
              row['channel_name'],
              row['video_name'],
              row['video_date'],
              row['video_description'],
              row['video_duration'],
              row['video_views'],
              row['video_likes'],
              row['video_favourite'],
              row['video_comment_count']
             )
    try:
        mycursor.execute(insert_query, values)
    except Exception as e:
        print(f"Error inserting data: {e}")

com_list = []
db = client["youtube"]
coll1 = db["channel_details"]

for com_data in coll1.find({}, {"_id": 0, " comment_information":1}):
    comment_info = com_data.get(" comment_information")
    if comment_info is not None:
        com_list.extend(comment_info)

df2= pd.DataFrame(com_list)
df2

create_query = '''CREATE TABLE IF NOT EXISTS youtube.comment_information (
                   comment_id VARCHAR(255),
                   video_id VARCHAR(255),
                   comment_text TEXT,
                   comment_author VARCHAR(255),
                   commented_on VARCHAR(255)
                )'''

try:
    mycursor.execute(create_query)
except Exception as e:
    print(f"Error creating table: {e}")

for index, row in df2.iterrows():
    insert_query = '''Insert into comment_information(comment_id,
                                                      video_id,
                                                      comment_text,
                                                      comment_author,
                                                      commented_on)
                      values (%s, %s, %s, %s, %s)'''
    values = (row['comment_id'],
              row['video_id'],
              row['comment_text'],
              row['comment_author'],
              row['commented_on'])
    try:
        mycursor.execute(insert_query, values)
    except Exception as e:
        print(f"Error inserting data: {e}")

def tables():
    show_table_channel_information()
    show_table_video_information()
    show_table_comment_information()
    return "tables created successfully"

def show_table_channel_information():
    ch_list = []
    db = client["youtube"]
    coll1 = db["channel_details"]
    for ch_data in coll1.find({},{"_id":0}):
        ch_list.append(ch_data["channel_information"])
    df = st.dataframe(ch_list)
    return df



def show_table_video_information():
    vi_list = []
    db = client["youtube"]
    coll1 = db["channel_details"]
    for vi_data in coll1.find({}, {"_id": 0, "video_information": 1}):
        video_info = vi_data.get("video_information")
        if video_info is not None:
            vi_list.extend(video_info)
    df1 = st.dataframe(vi_list)
    return df1


def show_table_comment_information():
    com_list = []
    db = client["youtube"]
    coll1 = db["channel_details"]

    for com_data in coll1.find({}, {"_id": 0, " comment_information":1}):
        comment_info = com_data.get(" comment_information")
        if comment_info is not None:
           com_list.extend(comment_info)
    df2 = st.dataframe(com_list)
    return df2

# streamlit part
with st.sidebar:
    st.title(":red[Youtube Data Harvesting & Warehousing]")
    with st.sidebar:
        st.markdown(f'''
             <style>
             section[data-testid="stSidebar"] {{
                     width: 500px;
                     background-color: #000b1a;
                     }}
             section[data-testid="stSidebar"] h1 {{
                     color: #e3eefc;
                     }}
             section[data-testid="stSidebar"] p {{
                     color: #ddd;
                     text-align: left;
                     }}
             section[data-testid="stSidebar"] svg {{
                     fill: #ddd;
                     }}
             </style>
         ''', unsafe_allow_html=True)
        st.title(":anchor: About the Project")
        st.markdown(
            "The problem statement is to create a Streamlit application that allows users to access and analyze data from multiple YouTube channels. The application should have the following features: Ability to input a YouTube channel ID and retrieve all the relevant data (Channel name, subscribers, total video count, playlist ID, video ID, likes, dislikes, comments of each video) using Google API. Option to store the data in a MongoDB database as a data lake. Ability to collect data for up to 10 different YouTube channels and store them in the data lake by clicking a button. Option to select a channel name and migrate its data from the data lake to a SQL database as tables. Ability to search and retrieve data from the SQL database using different search options, including joining tables to get channel details.")


    st.header(":red[Home]")
    st.caption("Data Collection & Storage")
    st.caption("Data Transformation")
    st.caption("Data Analysis")

channel_id = st.text_input("Enter the Channel_id")
if st.button("Data Collection"):

    ch_list = []
    db = client["youtube"]
    coll1 = db["channel_details"]
    for ch_data in coll1.find({}, {"_id": 0}):
        ch_list.append(ch_data["channel_information"]["channel_id"])

    if channel_id in ch_list:
        st.success("Channel details of the given channel ids exists")
    else:
        insert = get_channel_details_1(channel_id)
        st.success(insert)

if st.button("Data Transformation"):
        Table = tables()
        st.success(Table)

show_table = st.radio("Select the table for view", ("Channels", "Videos", "Comments"))

if show_table == "Channels":
            show_table_channel_information()

elif show_table == "Videos":
        show_table_video_information()

elif show_table == "Comments":
        show_table_comment_information()


#SQL CONNECTION
import mysql.connector
mycon = mysql.connector.connect(
        host = "localhost",
        user = "root",
        password="12345",
        database = "youtube"
)
mycursor = mycon.cursor()

# User selects a question
question = st.selectbox("Select Query", [
    "What are the names of all the videos and their corresponding channels?",
    "Which channels have the most number of videos, and how many videos do they have?",
    "What are the top 10 most viewed videos and their respective channels?",
    "How many comments were made on each video, and what are their corresponding video names?",
    "Which videos have the highest number of likes, and what are their corresponding channel names?",
    "What is the total number of likes and dislikes for each video, and what are their corresponding video names?",
    "What is the total number of views for each channel, and what are their corresponding channel names?",
    "What are the names of all the channels that have published videos in the year 2022?",
    "What is the average duration of all videos in each channel, and what are their corresponding channel names?",
    "Which videos have the highest number of comments, and what are their corresponding channel names?"
])

# Database connection string
connection_string = 'mysql://root:12345@localhost:3306/youtube'
engine = sa.create_engine(connection_string)

# Execute the selected query based on the question
if question == "What are the names of all the videos and their corresponding channels?":
    query = "SELECT channel_name, video_name from video_information"
elif question == "Which channels have the most number of videos, and how many videos do they have?":
    query = "SELECT channel_name, channel_video_count FROM youtube.channel_information WHERE channel_video_count = (SELECT MAX(channel_video_count) FROM youtube.channel_information);"
elif question == "What are the top 10 most viewed videos and their respective channels?":
    query = "SELECT channel_name, video_views FROM video_information where video_views is not null order by video_views desc limit 10"
elif question == " How many comments were made on each video, and what are theircorresponding video names?":
    query = "SELECT video_name,video_comment_count FROM youtube.video_information"
elif question == "Which videos have the highest number of likes, and what are their corresponding channel names?":
    query = "select channel_name, video_likes from  youtube.video_information where video_likes is not null order by video_likes desc"
elif question == "What is the total number of likes and dislikes for each video, and what are their corresponding video names?":
    query = "SELECT video_name,video_likes  FROM youtube.video_information"
elif question == "What is the total number of views for each channel, and what are their corresponding channel names?":
    query = "SELECT channel_name,channel_views FROM youtube.channel_information order by channel_views desc"
elif question == "What are the names of all the channels that have published videos in the year 2022?":
    query = "SELECT channel_name, video_date   FROM youtube.video_information"
elif question == "What is the average duration of all videos in each channel, and what are their corresponding channel names?":
    query = "select video_duration, channel_name from youtube.video_information where video_duration=(select avg(video_duration) from youtube.video_information)"
elif question == "Which videos have the highest number of comments, and what are their corresponding channel names?":
    query = "select video_comment_count, channel_name from video_information where video_comment_count=(select max(video_comment_count) from video_information)"

# Execute the query and display the result
with engine.connect() as connection:
    result_df = pd.read_sql(query, connection)

st.dataframe(result_df)


